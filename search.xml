<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Add toc in the article (hexo)</title>
      <link href="/2023/08/25/Software-Setting-Hexo-hexo/"/>
      <url>/2023/08/25/Software-Setting-Hexo-hexo/</url>
      
        <content type="html"><![CDATA[<h2><span id="1-install-hexo-toc-plug-in">1. install hexo-toc plug-in</span></h2><pre class="line-numbers language-css" data-language="css"><code class="language-css">npm install hexo-toc --save<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2><span id="2-add-such-code-in-the-file-of-the-theme">2. add such code in the file of the theme</span></h2><pre class="line-numbers language-YAML" data-language="YAML"><code class="language-YAML">toc:  max_depth: 3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2><span id="3-add-such-code-in-the-article">3. add such code in the article</span></h2><pre class="line-numbers language-MARKDOWN" data-language="MARKDOWN"><code class="language-MARKDOWN">---title: My Article---&lt;!-- toc --&gt;## Section 1...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2><span id="4-generate-the-website-to-check">4. generate the website to check</span></h2><pre class="line-numbers language-css" data-language="css"><code class="language-css">hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-css" data-language="css"><code class="language-css">hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2><span id="5-final-effect">5. Final effect</span></h2><p><img src="https://raw.githubusercontent.com/kathychen47/Img4KathyBlog/main/toc.png"></p>]]></content>
      
      
      <categories>
          
          <category> Software Setting </category>
          
          <category> Kaggle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CT Artifacts(Intro)</title>
      <link href="/2023/04/09/Computed-Tomography-Artifacts-CT-Artifacts-Intro/"/>
      <url>/2023/04/09/Computed-Tomography-Artifacts-CT-Artifacts-Intro/</url>
      
        <content type="html"><![CDATA[<h2><span id="artifact-definition">Artifact Definition</span></h2><p>Any <code>systematic</code> discrepancy between the CT numbers in the reconstructed image and the true attenuation coefficients of the object.</p><h2><span id="appearance-of-ct-artifacts">Appearance of CT artifacts</span></h2><p>• <strong>Streaks</strong> – due to an inconsistency in a single measurement</p><p>• <strong>Shading</strong> – due to a group of channels or views deviating gradually from the true measurement</p><p>• <strong>Rings</strong> – due to errors in an individual detector calibration</p><p>• <strong>Distortion</strong> – due to helical reconstruction</p><h2><span id="sources-of-artifacts-come-from-four-categories">Sources of artifacts come from four categories</span></h2><p>• <strong>Physics-based</strong> – result from the physical processes involved in the acquisition of CT data</p><p>• <strong>Patient-based</strong> – caused by such factors as patient movement or the presence of metallic materials in or on the patient</p><p>• <strong>Scanner-based</strong> – result from imperfections in scanner function</p><p>• <strong>Helical and</strong> <strong>multi-section</strong> <strong>artifacts</strong> – produced by the image reconstruction process</p><h3><span id="physics-based-4-types"><em>Physics based (4 types)</em></span></h3><ol><li><p><strong>Beam hardening –</strong> due to average E of beam increasing as beam traverses object. Results in two different visual artifacts: 1) cupping, and 2) streaks and dark bands.</p><blockquote><p>When X-rays pass through high-density objects such as bones or metals, their likelihood of interacting with the atomic nuclei or electrons in the material is higher, which causes a change in the average energy of the X-rays. In this case, <em>the average energy of the X-rays</em> may increase because of the photoelectric effect and Compton scattering that occur when they interact with the material, with the photoelectric effect potentially causing an increase in the X-ray energy.</p><p>small <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.294ex" height="1.025ex" role="img" focusable="false" viewbox="0 -442 572 453"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D462" d="M21 287Q21 295 30 318T55 370T99 420T158 442Q204 442 227 417T250 358Q250 340 216 246T182 105Q182 62 196 45T238 27T291 44T328 78L339 95Q341 99 377 247Q407 367 413 387T427 416Q444 431 463 431Q480 431 488 421T496 402L420 84Q419 79 419 68Q419 43 426 35T447 26Q469 29 482 57T512 145Q514 153 532 153Q551 153 551 144Q550 139 549 130T540 98T523 55T498 17T462 -8Q454 -10 438 -10Q372 -10 347 46Q345 45 336 36T318 21T296 6T267 -6T233 -11Q189 -11 155 7Q103 38 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container> -&gt;dark large <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.294ex" height="1.025ex" role="img" focusable="false" viewbox="0 -442 572 453"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D462" d="M21 287Q21 295 30 318T55 370T99 420T158 442Q204 442 227 417T250 358Q250 340 216 246T182 105Q182 62 196 45T238 27T291 44T328 78L339 95Q341 99 377 247Q407 367 413 387T427 416Q444 431 463 431Q480 431 488 421T496 402L420 84Q419 79 419 68Q419 43 426 35T447 26Q469 29 482 57T512 145Q514 153 532 153Q551 153 551 144Q550 139 549 130T540 98T523 55T498 17T462 -8Q454 -10 438 -10Q372 -10 347 46Q345 45 336 36T318 21T296 6T267 -6T233 -11Q189 -11 155 7Q103 38 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container> -&gt; light</p></blockquote><ul><li><p><strong>Cupping</strong>: X-rays passing through the center of an object experience greater attenuation (and thus more hardening) than those that pass through the edges of the object –showing as light at the edge and dark inside</p></li><li><p><strong>Streaks and dark bands:</strong> Appear between two high density objects (such as bone or contrast media). Due to greater hardening at angles that beam passes through both structures than just one. Many more clinical examples on this than cupping.</p></li></ul><p>There are three method can be used to <strong>minimize beam hardening</strong>:</p><ul><li><p><strong>filtration (bow tie)</strong> – Bowtie filtration hardens edges more than center</p></li><li><p><strong>calibration correction</strong> – manufacturer calibrates beams for different body parts using phantoms. Usually helps with cupping artifact but can still result in small cupping or capping (opposite effect) due to differences between patient and phantom.</p></li><li><p><strong>software</strong> – usually uses iterative reconstruction. Improves bone/tissue interfaces and streaking</p></li></ul></li><li><p><strong>Partial volume –</strong> object within FOV at certain angles and not within FOV at other angles</p><ul><li>Corrected by using thin slices. If noise in slices becomes an issue, sum slices (but don’t raise slice width).</li></ul><blockquote><p>It occurs when:</p><ul><li>The slice is too thick</li><li>only contain projection from limited angles</li><li>slice only contain some part of our object</li></ul></blockquote></li><li><p><strong>Photon starvation –</strong> attenuation is very great at certain angles creating noisy projections. Reconstruction amplifies noise and results in streaking at these projections</p><blockquote><p>For example, shoulder in this image, is very thick from the right-and-left, so the photon will attenuated very quickly. However, it is very thin from the up-and-down. It will causes streaking artifacts when reconstruction.</p></blockquote></li></ol><ul><li>Corrected using tube current modulation or adaptive filtering.</li></ul><ol start="4"><li><p><strong>Angular</strong> <strong>under-sampling</strong> <strong>–</strong> too few angles acquired creates view aliasing where fine lines appear to radiate from the edges of a structure</p><ul><li>Corrected using more angles or special techniques that increase data acquired per angle such as quarter-detector shift or flying-focal spot.</li></ul></li></ol><h3><span id="patient-based-3-types"><strong><em>Patient-based (3 types)</em></strong></span></h3><ol><li><p><strong>Metallic materials –</strong> presence of metal creates streaking artifacts due to beam hardening and/or photon starvation</p><ul><li>Corrected by removing metal objects and/or software</li></ul></li><li><p><strong>Motion –</strong> causes misregistration artifacts that lead to shading or streaking</p><ul><li><p>Corrected by:</p><ul><li><strong>Positioning –</strong> ensure patient is comfortable and that involuntary motions of un-important organs are not included in the FOV</li></ul></li><li><p><strong>Restraints –</strong> often needed for children</p></li><li><p><strong>Breath-holding –</strong> removes respiratory motion</p></li><li><p><strong>Overscanning</strong> <strong>–</strong> acquire more than 360 degrees and average beginning and ending (since motion discrepency is greatest at these points)</p><ul><li><strong>Software –</strong> de-weight beginning and ending angles</li></ul></li><li><p><strong>Cardiac gating –</strong> only acquire at certain phases of cardiac cycle (e.g. end-diastole)</p></li></ul></li><li><p><strong>Incomplete projections</strong></p><ul><li><p>Correct by:</p><ul><li><p>ensuring no objects (such as body parts or tubes of contrast material) lie outside the FOV. Some manufacturers attempt to recognize objects moving in and out of FOV.</p></li><li><p>Similar to dense tube containing contrast media outside the scan field; or Blocking the reference channels at the sides of the detectors</p></li><li><p>using large bore</p></li></ul></li></ul></li></ol><h3><span id="scanner-based-1-types"><em><strong>Scanner-based (1 types)</strong></em></span></h3><ol><li><strong>Ring artifacts –</strong> out of calibration or dead detector element creates circular artifact. Worse if element is near the center of the detector as this may <em>create a hole in the center of the image</em>.</li></ol><h3><span id="helical-and-multi-section-artifacts-4-types"><em><strong>Helical and</strong> <strong>multi-section</strong> <strong>artifacts (4 types)</strong></em></span></h3><ol><li><p><strong>Single section artifacts –</strong> interpolation of slices creates distortion. More pronounced at large pitch values and when object changes rapidly in z-direction.</p></li><li><p><strong>Multi-section</strong> <strong>artifacts –</strong> sources of artifacts are more complicated, but commonly have a windmill appearance.</p><ul><li>Corrected by using z-filter interpolators or non-integer values for pitch (e.g. 3.5 or 4.5)</li></ul></li><li><p><strong>Cone beam effects –</strong> outer edges of FOV contain information not seen in other views (similar to partial volume effects)</p><img src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRckcuI2YFGG9VZWRhusDnn6ISSgIfQXqDazA&usqp=CAU" style="zoom:67%;"><ul><li>Corrected using non-standard reconstruction techniques</li></ul></li><li><p><strong>Multi-planer</strong> <strong>and three-dimensional reformation</strong></p><ul><li><strong>Stair-step artifacts</strong> – Virtually eliminated on modern multislice scanners using thin sections</li><li><strong>Zebra artifacts</strong> – faint stripes due to enhanced noise inhomogeneity along z-axis.</li></ul></li></ol><h2><span id="reference">Reference</span></h2><p>[1] Barrett, J. F., &amp; Keat, N. (2004). Artifacts in CT: recognition and avoidance. <em>Radiographics</em>, <em>24</em>(6), 1679-1691.</p>]]></content>
      
      
      <categories>
          
          <category> Computed Tomography </category>
          
          <category> Artifacts </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CT </tag>
            
            <tag> Artifacts </tag>
            
            <tag> CT Artifacts </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Filter Back Projection (FBP)</title>
      <link href="/2023/04/06/Computed-Tomography-Recon-Filter-Back-Projection-FBP/"/>
      <url>/2023/04/06/Computed-Tomography-Recon-Filter-Back-Projection-FBP/</url>
      
        <content type="html"><![CDATA[<h2><span id="code-in-python">Code In Python</span></h2><ol><li>fbp.py</li></ol><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">import pydicomfrom PIL import Image, ImageOpsimport matplotlib.pyplot as pltimport numpy as npfrom scipy.fftpack import fft, ifft, fftshiftimport fbpdef arange2(start, stop=None, step=1):    """#Modified version of numpy.arange which corrects error associated with non-integer step size"""    if stop == None:        a = np.arange(start)    else:        a = np.arange(start, stop, step)        if a[-1] &gt; stop-step:            a = np.delete(a, -1)    return adef getProj(img,theta):    numAngles = len(theta)    sinogram = np.zeros((img.size[0], numAngles))    # Iteratively calculate the integral value of each projection    for n in range(numAngles):        theta = np.linspace(0., 180., numAngles, endpoint=False)        # rotate the image        rotImgObj = img.rotate(90-theta[n], resample=Image.BICUBIC)        # calculate the integral value of porjection        sinogram[:,n] = np.sum(rotImgObj, axis=0)    return sinogramdef filterProj(sinogram):    projLen, numAngles = sinogram.shape    step = 2 * np.pi / projLen    w = fbp.arange2(-np.pi, np.pi, step)    if len(w)&lt;projLen:        w = np.concatenate([w, [w[-1] + step]])    ramp_filter = np.abs(w)    ramp_filter = fftshift(ramp_filter)  # shifts the zero-frequency component of the discrete Fourier transform (DFT) to the center of the arraydef filterProj2(sinogram,a=0.1):    projLen, numAngles = sinogram.shape    step = 2 * np.pi / projLen    w = arange2(-np.pi, np.pi, step)    if len(w) &lt; projLen:        w = np.concatenate([w, [w[-1] + step]])  # depending on image size, it might be that len(w) =        # projLen - 1. Another element is added to w in this case    rn1 = abs(2 / a * np.sin(a * w / 2));  # approximation of ramp filter abs(w) with a funciton abs(sin(w))    rn2 = np.sin(a * w / 2) / (a * w / 2);  # sinc window with 'a' modifying the cutoff freqs    ramp_filter = rn1 * (rn2) ** 2;    ramp_filter = fftshift(ramp_filter)    filter_sinogram = np.zeros_like(sinogram)    for i in range(numAngles):        projfft = fft(sinogram[:, i])  # one dimentional Fourier transform        filter_projfft = projfft * ramp_filter  # *ramp_filter        filter_proj = np.real(ifft(filter_projfft))  # inverse Fourier transform        filter_sinogram[:, i] = filter_proj    plt.imshow(filter_sinogram, cmap='gray')    plt.title("filter_sinogram")    plt.show()    return filter_sinogramdef backPorj(filter_sinogram, theta):    # define a empty reconstruction image    N = filter_sinogram.shape[0]    reconImg = np.zeros((N, N))  # the length of image is equal to the length of detector    # Create a grid coordinate system with the center point at (0,0) in which the origin of the image coordinate system,    # which is located at the upper left corner, is shifted to the center point.    X = fbp.arange2(N) - N / 2  # [-N/2,...0..+N/2]    Y = X.copy()    x, y = np.meshgrid(X, Y)  # generate grid coordinate    # Convert degrees to radians    theta = theta * np.pi / 180    numAngles = len(theta)    for n in range(numAngles):        t = x * np.sin(theta[n]) + y * np.cos(theta[n])  # x-y -&gt; t-s        # s = -x*np.sin(theta[n])+y*np.cos(theta[n])        tCor = np.round(            t + N / 2)  # Shift the coordinate axis origin to match the image origin. round() may result in floating-point numbers, needs to be rounded to an integer.        tCor = tCor.astype("int")        tIndex, sIndex = np.where((tCor &gt;= 0) &amp; (tCor &lt;= N - 1))  # tIndex: row index; sIndex: column Index        sino_angle_n = filter_sinogram[:, n]        reconImg[tIndex, sIndex] += sino_angle_n[tCor[tIndex, sIndex]]        # plt.imshow(reconImg, cmap='gray')        # plt.title('Image {}'.format(n))        # plt.show()    reconImg = Image.fromarray((reconImg - np.min(reconImg)) / np.ptp(reconImg) * 255)  # normilization    fig = plt.imshow(reconImg)    plt.title('reconImg')    plt.show()    return reconImgdef lineProfile(height, img, reconImg):    line_profile = np.array(img)[height, :]    recon_line_profile = np.array(reconImg)[height, :]    plt.plot(line_profile, label='Original Image')    plt.plot(recon_line_profile, label='Reconstructed Image')    plt.xlabel('Pixel Value')    plt.ylabel('Intensity')    plt.title('Line Profile at Pixel height= {}'.format(height))    plt.legend()    plt.show()    return line_profile, recon_line_profile<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>main.py</li></ol><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">import fbpfrom PIL import Image, ImageChops, ImageOpsimport pydicomimport matplotlib.pyplot as pltimport numpy as npfrom scipy.fftpack import fft, ifft, fftshiftimport loggingimport pickleimport jsonif __name__ == '__main__':    # generate output logging    logging.basicConfig(filename='output.log', level=logging.DEBUG)    logger = logging.getLogger(__name__)    # --------------------------------------------------Load data----------------------------------------------------------    dcm = pydicom.dcmread('C:\\Users\\Kathy\\Desktop\\DL\FBP\\1.2.826.0.1.3680043.5876\\1.dcm')    img = Image.fromarray(dcm.pixel_array).convert('L')    # img = np.asarray(img)    # img = (img - np.min(img)) / np.ptp(img) * 255    # img = img.astype(np.uint8)    # img = Image.fromarray(img)    logger.debug(f"Original_img: {img}")    plt.imshow(img, cmap='gray')    plt.title("original_image")    plt.show()    # -----------------------------------------------Forward Projection-----------------------------------------------------    # Define rotation angle and the number of rotation    numAngles = 720    theta = np.linspace(0., 180., numAngles, endpoint=False)    sinogram = fbp.getProj(img, theta)    logger.debug(f"sinogram: {sinogram}")    # -----------------------------------------------sinogram filteration---------------------------------------------------    filter_sinogram=fbp.filterProj2(sinogram)    logger.debug(f"filter_sinogram: {filter_sinogram}")    # --------------------------------------------- Back Projection/ Recon -------------------------------------------------    reconImg = fbp.backPorj(filter_sinogram, theta)    logger.debug(f"reconImg: {reconImg}")    # generate lineProfile    fbp.lineProfile(200,img,reconImg)    # Load logging    with open('output.log', 'r') as f:        content = f.readlines()        print(content)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Computed Tomography </category>
          
          <category> Reconstruction </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CT </tag>
            
            <tag> FBP </tag>
            
            <tag> Filter Back Projection </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>How to Download Kaggle dataset in Linux server</title>
      <link href="/2023/02/28/Software-Setting-Kaggle-How-to-Download-Kaggle-dataset-in-Linux-server/"/>
      <url>/2023/02/28/Software-Setting-Kaggle-How-to-Download-Kaggle-dataset-in-Linux-server/</url>
      
        <content type="html"><![CDATA[<h2><span id="1-install-kaggle-in-linux">1. Install Kaggle in Linux</span></h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">pip install kaggle<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2><span id="2-get-kaggle-api">2. Get Kaggle API</span></h2><p>Kaggle -&gt; Account -&gt; Create New API Token -&gt; download kaggle.json -&gt; move kaggle. json file to home/user/.kaggle in linux</p><h2><span id="3-change-download-directory">3. Change Download Directory</span></h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">kaggle config set -n path -v /data/XRay_data<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2><span id="4-download-dataset">4. Download Dataset</span></h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">kaggle competitions download -c rsna-2022-cervical-spine-fracture-detection<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Software Setting </category>
          
          <category> Kaggle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kaggle </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
